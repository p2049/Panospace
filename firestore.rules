rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // USERS COLLECTION
    // ============================================
    match /users/{userId} {
      // Public read for user profiles
      allow read: if true;
      
      // Users can only create/update their own profile
      allow create: if request.auth != null && request.auth.uid == userId;
      allow update: if request.auth != null && request.auth.uid == userId;
      
      // Validate user data structure
      allow write: if request.resource.data.keys().hasAll(['displayName']) &&
                     request.resource.data.displayName is string;
      
      // ----------------------------------------
      // USER SUBCOLLECTIONS (nested for proper listen access)
      // ----------------------------------------
      
      // Custom Feeds - supports onSnapshot listeners
      match /customFeeds/{feedId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow create, update, delete: if request.auth != null && request.auth.uid == userId;
      }
      
      // Blocked Users - supports getDocs queries
      match /blockedUsers/{blockedUserId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }
    
    // ============================================
    // POSTS COLLECTION (Portfolio Posts)
    // ============================================
    match /posts/{postId} {
      // Public read for all posts
      allow read: if true;
      
      // Authenticated users can create posts
      // Support both userId (new) and authorId (legacy)
      allow create: if request.auth != null &&
                     (request.resource.data.userId == request.auth.uid ||
                      request.resource.data.authorId == request.auth.uid) &&
                     request.resource.data.keys().hasAny(['userId', 'authorId']) &&
                     request.resource.data.keys().hasAll(['createdAt']) &&
                     request.resource.data.tags is list &&
                     request.resource.data.createdAt is timestamp;
      
      // Users can update/delete only their own posts
      // Support both userId (new) and authorId (legacy)
      allow update, delete: if request.auth != null &&
                               (resource.data.userId == request.auth.uid ||
                                resource.data.authorId == request.auth.uid);
      
      // üîê SECURITY: Prevent manipulation of engagement metrics
      allow update: if !request.resource.data.diff(resource.data).affectedKeys().hasAny(['likeCount', 'commentCount', 'viewCount']);
      
      // Allow users to boost their own posts
      allow update: if request.auth != null &&
                      (resource.data.userId == request.auth.uid || resource.data.authorId == request.auth.uid) &&
                      request.resource.data.diff(resource.data).affectedKeys()
                        .hasOnly(['boostLevel', 'boostMultiplier', 'boostExpiresAt', 'isBoosted', 'boostedAt']);
      
      // Validate tags array
      allow write: if !request.resource.data.keys().hasAny(['tags']) ||
                     (request.resource.data.tags is list && 
                      request.resource.data.tags.size() <= 20);
                      
      // Validate location object if present
      allow write: if !request.resource.data.keys().hasAny(['location']) ||
                     (request.resource.data.location is map);
                     
      // Validate shopLinked boolean
      allow write: if !request.resource.data.keys().hasAny(['shopLinked']) ||
                     (request.resource.data.shopLinked is bool);
                     
      // Validate status field
      allow write: if !request.resource.data.keys().hasAny(['status']) ||
                     (request.resource.data.status in ['published', 'draft']);
      
      // üîê SECURITY: Validate title length (max 200 chars)
      allow write: if !request.resource.data.keys().hasAny(['title']) ||
                     (request.resource.data.title is string && 
                      request.resource.data.title.size() <= 200);
      
      // üîê SECURITY: Validate description length (max 2000 chars)
      allow write: if !request.resource.data.keys().hasAny(['description']) ||
                     (request.resource.data.description is string && 
                      request.resource.data.description.size() <= 2000);
      
      // üîê SECURITY: Validate images are from Firebase Storage
      allow write: if !request.resource.data.keys().hasAny(['images']) ||
                     (request.resource.data.images is list &&
                      request.resource.data.images.size() > 0 &&
                      request.resource.data.images.size() <= 10;
                      // request.resource.data.images[0].url.matches('.*firebasestorage\\.googleapis\\.com.*'));
    }
    
    // ============================================
    // SHOP ITEMS COLLECTION
    // ============================================
    match /shopItems/{itemId} {
      // Public read for shop items
      allow read: if true;
      
      // Authenticated users can create shop items
      // Support both userId (new) and authorId (legacy)
      allow create: if request.auth != null &&
                     (request.resource.data.userId == request.auth.uid ||
                      request.resource.data.authorId == request.auth.uid) &&
                     // Enforce Seller Verification - DISABLED FOR PROD DEBUGGING
                     // get(/databases/$(database)/documents/users/$(request.auth.uid)).data.sellerStatus == 'verified' &&
                     request.resource.data.keys().hasAny(['userId', 'authorId']) &&
                     request.resource.data.keys().hasAll(['title', 'createdAt']) &&
                     request.resource.data.createdAt is timestamp;
      
      // Users can update/delete only their own shop items
      // Support both userId (new) and authorId (legacy)
      allow update, delete: if request.auth != null &&
                               (resource.data.userId == request.auth.uid ||
                                resource.data.authorId == request.auth.uid);
      
      // Validate print Sizes array if present
      allow write: if !request.resource.data.keys().hasAny(['printSizes']) ||
                     (request.resource.data.printSizes is list);
      
      // Validate available boolean
      allow write: if !request.resource.data.keys().hasAny(['available']) ||
                     (request.resource.data.available is bool);
    }
    
    // ============================================
    // FOLLOWS COLLECTION
    // ============================================
    match /follows/{followId} {
      // Public read for follows
      allow read: if true;
      
      // Users can create follow documents
      allow create: if request.auth != null &&
                     request.resource.data.followerId == request.auth.uid &&
                     request.resource.data.keys().hasAll(['followerId', 'followingId', 'createdAt']) &&
                     request.resource.data.followerId is string &&
                     request.resource.data.followingId is string &&
                     request.resource.data.createdAt is timestamp;
      
      // Users can only delete their own follow documents
      allow delete: if request.auth != null &&
                     resource.data.followerId == request.auth.uid;
    }
    
    // ============================================
    // LIKES COLLECTION
    // ============================================
    match /likes/{likeId} {
      // Public read for likes
      allow read: if true;
      
      // Users can create/delete their own likes
      allow create: if request.auth != null &&
                     request.resource.data.userId == request.auth.uid &&
                     request.resource.data.keys().hasAll(['userId', 'postId', 'createdAt']) &&
                     request.resource.data.userId is string &&
                     request.resource.data.postId is string &&
                     request.resource.data.createdAt is timestamp;
      
      allow delete: if request.auth != null &&
                     resource.data.userId == request.auth.uid;
    }
    
    // ============================================
    // ORDERS COLLECTION
    // ============================================
    match /orders/{orderId} {
      // Users can read their own orders
      allow read: if request.auth != null && resource.data.userId == request.auth.uid;
      
      // No client-side writes allowed (handled by backend)
      allow write: if false;
    }

    // ============================================
    // COLLECTIONS
    // ============================================
    match /collections/{collectionId} {
      // Read based on visibility
      allow read: if resource.data.visibility == 'public' ||
                    (request.auth != null && resource.data.ownerId == request.auth.uid) ||
                    (request.auth != null && resource.data.visibility == 'followers');
      
      // Authenticated users can create collections
      allow create: if request.auth != null &&
                     request.resource.data.ownerId == request.auth.uid &&
                     request.resource.data.keys().hasAll(['title', 'ownerId', 'createdAt', 'visibility']) &&
                     request.resource.data.title is string &&
                     request.resource.data.ownerId is string &&
                     request.resource.data.createdAt is timestamp &&
                     request.resource.data.visibility in ['public', 'followers', 'private'] &&
                     (!request.resource.data.keys().hasAny(['items']) || request.resource.data.items is list) &&
                     (!request.resource.data.keys().hasAny(['postRefs']) || request.resource.data.postRefs is list);
      
      // Users can update/delete only their own collections
      allow update, delete: if request.auth != null &&
                               resource.data.ownerId == request.auth.uid;
      
      // Validate items array (max 10 items at creation)
      allow write: if !request.resource.data.keys().hasAny(['items']) ||
                     (request.resource.data.items is list &&
                      request.resource.data.items.size() <= 10);
      
      // Validate postRefs array (no limit on posts added)
      allow write: if !request.resource.data.keys().hasAny(['postRefs']) ||
                     request.resource.data.postRefs is list;
      
      // Validate shopSettings
      allow write: if !request.resource.data.keys().hasAny(['shopSettings']) ||
                     (request.resource.data.shopSettings is map &&
                      request.resource.data.shopSettings.showInStore is bool);
    }

    // ============================================
    // EVENTS COLLECTION (Community Calendar)
    // ============================================
    match /events/{eventId} {
      // Public read for all events
      allow read: if true;
      
      // Authenticated users can create events
      allow create: if request.auth != null &&
                     request.resource.data.creatorId == request.auth.uid &&
                     request.resource.data.keys().hasAll(['creatorId', 'title', 'eventDate', 'createdAt']) &&
                     request.resource.data.title is string &&
                     request.resource.data.title.size() > 0 &&
                     request.resource.data.title.size() <= 100 &&
                     request.resource.data.eventDate is timestamp &&
                     request.resource.data.createdAt is timestamp;
      
      // Users can update/delete only their own events
      allow update, delete: if request.auth != null &&
                               resource.data.creatorId == request.auth.uid;
      
      // Validate event type
      allow write: if !request.resource.data.keys().hasAny(['eventType']) ||
                     request.resource.data.eventType in ['contest', 'seasonal', 'drop', 'user', 'scheduled_post', 'scheduled_collection'];
    }

    // ============================================
    // GLOBAL EVENTS COLLECTION (Astronomical, Holidays, etc.)
    // ============================================
    match /events_global/{eventId} {
      // Public read for global events (moon phases, holidays, etc.)
      allow read: if true;
      
      // No client-side writes (admin/backend only)
      allow write: if false;
    }

    // ============================================
    // APP EVENTS COLLECTION (Curated Platform Events)
    // ============================================
    match /events_app/{eventId} {
      // Public read for app-curated events
      allow read: if true;
      
      // No client-side writes (admin/backend only)
      allow write: if false;
    }

    // ============================================
    // EVENT SUBMISSIONS COLLECTION
    // ============================================
    match /eventSubmissions/{submissionId} {
      // Public read for submissions (to show in event galleries)
      allow read: if true;
      
      // Authenticated users can create submissions
      allow create: if request.auth != null &&
                     request.resource.data.createdBy == request.auth.uid &&
                     request.resource.data.keys().hasAll(['eventId', 'postId', 'createdBy', 'submittedAt']) &&
                     request.resource.data.eventId is string &&
                     request.resource.data.postId is string;
      
      // Users can delete their own submissions
      allow delete: if request.auth != null &&
                     resource.data.createdBy == request.auth.uid;
      
      // Users can update visibility of their own submissions
      allow update: if request.auth != null &&
                     resource.data.createdBy == request.auth.uid &&
                     request.resource.data.diff(resource.data).affectedKeys().hasOnly(['visible']);
    }
      
    // ============================================
    match /posts/{postId}/comments/{commentId} {
      allow read: if true;
      
      allow create: if request.auth != null &&
                     request.resource.data.userId == request.auth.uid &&
                     request.resource.data.keys().hasAll(['userId', 'text', 'createdAt']) &&
                     request.resource.data.text is string &&
                     request.resource.data.text.size() > 0 &&
                     request.resource.data.text.size() <= 500;
      
      allow update, delete: if request.auth != null &&
                               resource.data.userId == request.auth.uid;
    }

    // ============================================
    // CONTESTS COLLECTION (Full System)
    // ============================================
    match /contests/{contestId} {
      // Public read for all contests
      allow read: if true;
      
      // Authenticated users can create contests
      allow create: if request.auth != null &&
                     request.resource.data.creatorUid == request.auth.uid &&
                     request.resource.data.keys().hasAll(['title', 'startAt', 'endAt', 'entryType', 'status', 'createdAt']) &&
                     request.resource.data.entryType in ['free', 'paid'] &&
                     request.resource.data.status in ['upcoming', 'active', 'closed'];
      
      // Only creator can update/delete
      allow update, delete: if request.auth != null &&
                               resource.data.creatorUid == request.auth.uid;
      
      // Entries subcollection
      match /entries/{entryId} {
        // Public read for entries
        allow read: if true;
        
        // Users can create their own entries
        allow create: if request.auth != null &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.keys().hasAll(['userId', 'postId', 'submittedAt']) &&
                       request.resource.data.submittedAt is timestamp;
        
        // Users can delete their own entries (before contest closes)
        allow delete: if request.auth != null &&
                       resource.data.userId == request.auth.uid;
      }
    }

    // ============================================
    // USER INTEGRITY SCORES (Anti-Cheat)
    // ============================================
    match /userIntegrity/{userId} {
      // Users can read their own integrity score
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // No client-side writes (managed by Cloud Functions)
      allow write: if false;
    }

    // ============================================
    // MONTHLY WINNERS COLLECTION
    // ============================================
    match /monthlyWinners/{winnerId} {
      // Public read for winners
      allow read: if true;
      
      // No client-side writes (managed by Cloud Functions)
      allow write: if false;
    }

    // ============================================
    // WEEKLY LIKES TRACKING (Likes Lock System)
    // ============================================
    match /weeklyLikes/{docId} {
      // Users can read their own weekly stats
      allow read: if request.auth != null && 
                   docId.matches(request.auth.uid + '_.*');
      
      // Users can create/update their own weekly like tracking
      allow create, update: if request.auth != null &&
                              docId.matches(request.auth.uid + '_.*') &&
                              request.resource.data.userId == request.auth.uid &&
                              request.resource.data.keys().hasAll(['userId', 'weekStartTimestamp', 'likeCount']) &&
                              request.resource.data.likeCount is int &&
                              request.resource.data.likeCount >= 0;
    }
    // ============================================
    // REPORTS COLLECTION (Trust & Safety)
    // ============================================
    match /reports/{reportId} {
      // Create: Authenticated users can report
      allow create: if request.auth != null &&
                     request.resource.data.keys().hasAll(['type', 'reason', 'targetId', 'reportedBy', 'createdAt']) &&
                     request.resource.data.reportedBy == request.auth.uid;

      // Read/Update/Delete: Admin only
      // Note: You must set the 'admin' custom claim on your user account to access this
      allow read, update, delete: if request.auth != null && request.auth.token.admin == true;
    }
    // ============================================
    // SPACE CARDS (NFT-like Collectibles)
    // ============================================
    match /spaceCards/{cardId} {
      allow read: if true;
      allow create: if request.auth != null;
      
      // Allow update if creator OR if just updating stats (minting/listing)
      allow update: if request.auth != null && (
        resource.data.creatorUid == request.auth.uid || 
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['mintedCount', 'stats', 'updatedAt'])
      );
    }

    match /spaceCardOwnership/{ownershipId} {
      allow read: if true;
      
      // Create: Only for self (minting)
      allow create: if request.auth != null && request.resource.data.ownerId == request.auth.uid;
      
      // Update: Owner listing for sale OR Buyer purchasing
      allow update: if request.auth != null && (
        // Owner updating (e.g. listing for sale)
        resource.data.ownerId == request.auth.uid ||
        // Buyer purchasing (taking ownership)
        (request.resource.data.ownerId == request.auth.uid && resource.data.forSale == true)
      );
    }


    // NOTE: blockedUsers rules are now nested under /users/{userId} above

      
    // ============================================
    match /posts/{postId}/comments/{commentId} {
      allow read: if true;
      
      allow create: if request.auth != null &&
                     request.resource.data.userId == request.auth.uid &&
                     request.resource.data.keys().hasAll(['userId', 'text', 'createdAt']) &&
                     request.resource.data.text is string &&
                     request.resource.data.text.size() > 0 &&
                     request.resource.data.text.size() <= 500;
      
      allow update, delete: if request.auth != null &&
                               resource.data.userId == request.auth.uid;
    }

    // ============================================
    // CONTESTS COLLECTION (Full System)


    // ============================================
    // USER INTEGRITY SCORES (Anti-Cheat)
    // ============================================
    match /userIntegrity/{userId} {
      // Users can read their own integrity score
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // No client-side writes (managed by Cloud Functions)
      allow write: if false;
    }

    // ============================================
    // MONTHLY WINNERS COLLECTION
    // ============================================
    match /monthlyWinners/{winnerId} {
      // Public read for winners
      allow read: if true;
      
      // No client-side writes (managed by Cloud Functions)
      allow write: if false;
    }

    // ============================================
    // WEEKLY LIKES TRACKING (Likes Lock System)
    // ============================================
    match /weeklyLikes/{docId} {
      // Users can read their own weekly stats
      allow read: if request.auth != null && 
                   docId.matches(request.auth.uid + '_.*');
      
      // Users can create/update their own weekly like tracking
      allow create, update: if request.auth != null &&
                              docId.matches(request.auth.uid + '_.*') &&
                              request.resource.data.userId == request.auth.uid &&
                              request.resource.data.keys().hasAll(['userId', 'weekStartTimestamp', 'likeCount']) &&
                              request.resource.data.likeCount is int &&
                              request.resource.data.likeCount >= 0;
    }
    // ============================================
    // REPORTS COLLECTION (Trust & Safety)
    // ============================================
    match /reports/{reportId} {
      // Create: Authenticated users can report
      allow create: if request.auth != null &&
                     request.resource.data.keys().hasAll(['type', 'reason', 'targetId', 'reportedBy', 'createdAt']) &&
                     request.resource.data.reportedBy == request.auth.uid;

      // Read/Update/Delete: Admin only
      // Note: You must set the 'admin' custom claim on your user account to access this
      allow read, update, delete: if request.auth != null && request.auth.token.admin == true;
    }
    // ============================================
    // SPACE CARDS (NFT-like Collectibles)
    // ============================================



    // USER SUBCOLLECTIONS (continued)
    // ============================================
    match /users/{userId}/purchases/{purchaseId} {
      allow read: if true; // Publicly visible on profile
      allow write: if false; // Managed by backend
    }

    // COMMISSIONS (Marketplace)
    match /commissions/{commissionId} {
      // Users can read commissions they are involved in
      allow read: if request.auth != null && 
                   (resource.data.buyerId == request.auth.uid || 
                    resource.data.editorId == request.auth.uid);
      
      // Authenticated users can create commissions
      allow create: if request.auth != null &&
                     request.resource.data.buyerId == request.auth.uid &&
                     request.resource.data.keys().hasAll(['buyerId', 'editorId', 'price', 'status', 'createdAt']) &&
                     request.resource.data.price is number &&
                     request.resource.data.price > 0;
      
      // Only involved parties can update (e.g. status changes)
      allow update: if request.auth != null &&
                     (resource.data.buyerId == request.auth.uid || 
                      resource.data.editorId == request.auth.uid);
    }

    // INSTITUTIONS (B2B)
    match /institutions/{institutionId} {
      allow read: if true; // Public read for finding schools
      allow write: if false; // Only admin (via backend) can create/edit schools
    }

    match /users/{userId}/badges/{badgeId} {
      allow read: if true; // Publicly visible
      allow write: if false; // Managed by backend
    }

    // NOTE: customFeeds rules are now nested under /users/{userId} above

    // ============================================
    // GALLERIES COLLECTION (Collaborative Spaces)
    // ============================================
    match /galleries/{galleryId} {
      // Public read for all galleries
      allow read: if true;
      
      // Only premium users can create galleries (Premium check temporarily disabled for testing)
      allow create: if request.auth != null && 
                     // get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isPremium == true &&
                     request.resource.data.ownerId == request.auth.uid &&
                     request.resource.data.keys().hasAll(['title', 'ownerId', 'createdAt', 'contentType']) &&
                     request.resource.data.title is string &&
                     request.resource.data.title.size() > 0 &&
                     request.resource.data.title.size() <= 100 &&
                     request.resource.data.contentType in ['posts', 'collections', 'both'];
      
      // Only owner can update/delete
      allow update, delete: if request.auth != null && 
                             resource.data.ownerId == request.auth.uid;
      
      // Validate required tags array
      allow write: if !request.resource.data.keys().hasAny(['requiredTags']) ||
                     (request.resource.data.requiredTags is list &&
                      request.resource.data.requiredTags.size() <= 20);
      
      // Validate members array
      allow write: if !request.resource.data.keys().hasAny(['members']) ||
                     request.resource.data.members is list;
      
      // Gallery posts subcollection
      match /posts/{postId} {
        allow read: if true;
        
        // Members can add posts
        allow create: if request.auth != null && 
                       request.auth.uid in get(/databases/$(database)/documents/galleries/$(galleryId)).data.members &&
                       request.resource.data.addedBy == request.auth.uid;
        
        // Owner or post adder can delete
        allow delete: if request.auth != null && 
                       (request.auth.uid == resource.data.addedBy || 
                        request.auth.uid == get(/databases/$(database)/documents/galleries/$(galleryId)).data.ownerId);
      }
      
      // Gallery collections subcollection
      match /collections/{collectionId} {
        allow read: if true;
        
        // Members can add collections
        allow create: if request.auth != null && 
                       request.auth.uid in get(/databases/$(database)/documents/galleries/$(galleryId)).data.members &&
                       request.resource.data.addedBy == request.auth.uid;
        
        // Owner or collection adder can delete
        allow delete: if request.auth != null && 
                       (request.auth.uid == resource.data.addedBy || 
                        request.auth.uid == get(/databases/$(database)/documents/galleries/$(galleryId)).data.ownerId);
      }
      
      // Gallery invites subcollection
      match /invites/{inviteId} {
        // Users can read their own invites
        allow read: if request.auth != null && 
                     resource.data.userId == request.auth.uid;
        
        // Owner can create invites
        allow create: if request.auth != null && 
                       get(/databases/$(database)/documents/galleries/$(galleryId)).data.ownerId == request.auth.uid;
        
        // Invited user can update (accept/decline)
        allow update: if request.auth != null && 
                       resource.data.userId == request.auth.uid;
      }
    }

    // ============================================
    // USER SPACECARDS COLLECTION
    // ============================================
    match /user_spacecards/{docId} {
      // Users can read their own spacecards
      allow read: if request.auth != null && resource.data.userId == request.auth.uid;
      
      // Users can create their own spacecard entries
      allow create: if request.auth != null && 
                     request.resource.data.userId == request.auth.uid &&
                     request.resource.data.keys().hasAll(['userId', 'spacecardId', 'acquiredAt', 'method']) &&
                     request.resource.data.method in ['purchase', 'reward', 'free', 'challenge', 'event', 'soundtag-license'];
      
      // Immutable once created
      allow update, delete: if false;
    }

    // ============================================
    // SOUNDTAGS COLLECTION
    // ============================================
    match /soundtags/{soundtagId} {
      // Public read for all soundtags
      allow read: if true;
      
      // Authenticated users can create soundtags
      allow create: if request.auth != null &&
                     request.resource.data.artistId == request.auth.uid &&
                     request.resource.data.keys().hasAll(['artistId', 'title', 'audioUrl', 'createdAt']) &&
                     request.resource.data.title is string &&
                     request.resource.data.audioUrl is string &&
                     request.resource.data.audioUrl.matches('.*firebasestorage\\.googleapis\\.com.*');
      
      // Artists can update/delete their own soundtags
      allow update, delete: if request.auth != null &&
                               resource.data.artistId == request.auth.uid;
      
      // Validate price if present
      allow write: if !request.resource.data.keys().hasAny(['price']) ||
                     (request.resource.data.price is number && request.resource.data.price >= 0);
    }

    // ============================================
    // NOTIFICATIONS COLLECTION
    // ============================================
    match /notifications/{notificationId} {
      // Users can read their own notifications
      allow read: if request.auth != null && resource.data.userId == request.auth.uid;
      
      // System can create notifications (via Cloud Functions or client)
      allow create: if request.auth != null &&
                     request.resource.data.keys().hasAll(['userId', 'type', 'createdAt', 'read']) &&
                     request.resource.data.userId is string &&
                     request.resource.data.type is string &&
                     request.resource.data.createdAt is timestamp &&
                     request.resource.data.read is bool;
      
      // Users can update their own notifications (mark as read)
      allow update: if request.auth != null && 
                     resource.data.userId == request.auth.uid &&
                     request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'readAt']);
      
      // Users can delete their own notifications
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }

    // ============================================
    // PANODEX ENTRIES COLLECTION
    // ============================================
    match /panodex_entries/{entryId} {
      // Public read for all entries
      allow read: if true;
      
      // Authenticated users can create entries
      allow create: if request.auth != null &&
                     request.resource.data.keys().hasAll(['type', 'title', 'createdAt']) &&
                     request.resource.data.type in ['location', 'challenge', 'audio', 'landmark', 'style'] &&
                     request.resource.data.title is string;
      
      // Managed by backend - no client updates/deletes
      allow update, delete: if false;
    }
  }
}

